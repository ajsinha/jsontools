from __future__ import annotations

"""
Auto-generated by JsonSchemaCodeGen v1.1.0
Generated: 2026-01-29T13:36:20.814973

Copyright Â© 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
# Generated from: 16_media_library.json

"""
Auto-generated Python classes from JSON Schema.

Generated by JsonSchemaCodeGen on 2026-01-29 13:36:20

This module contains dataclasses generated from JSON Schema definitions.
Each class includes:
- Type hints for all properties
- Serialization methods (to_dict, to_json)
- Deserialization class methods (from_dict, from_json)
"""


import json
from dataclasses import dataclass, field, asdict
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, date
from typing import Dict, Any
from typing import List
from uuid import UUID


@dataclass
class MediaVariant:
    """Generated class for MediaVariant."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "url": "url",
            "format": "format",
            "name": "name",
            "quality": "quality",
            "width": "width",
            "height": "height",
            "duration": "duration",
            "bitrate": "bitrate",
            "fileSize": "fileSize"
        }

    id_: str
    url: str
    format: str
    name: Optional[str] = None
    quality: Optional["QualityEnum"] = None
    width: Optional[int] = None
    height: Optional[int] = None
    duration: Optional[float] = None
    bitrate: Optional[int] = None
    fileSize: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MediaVariant':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'MediaVariant':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class MediaMetadata:
    """Generated class for MediaMetadata."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "title": "title",
            "description": "description",
            "artist": "artist",
            "album": "album",
            "genre": "genre",
            "year": "year",
            "track": "track",
            "copyright": "copyright",
            "license": "license",
            "location": "location",
            "camera": "camera",
            "custom": "custom"
        }

    title: Optional[str] = None
    description: Optional[str] = None
    artist: Optional[str] = None
    album: Optional[str] = None
    genre: Optional[List[str]] = field(default_factory=list)
    year: Optional[int] = None
    track: Optional[int] = None
    copyright: Optional[str] = None
    license: Optional[str] = None
    location: Optional["Location"] = None
    camera: Optional["Camera"] = None
    custom: Optional[Dict[str, Any]] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MediaMetadata':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'MediaMetadata':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class GeoLocation:
    """Generated class for GeoLocation."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "latitude": "latitude",
            "longitude": "longitude",
            "altitude": "altitude",
            "placeName": "placeName"
        }

    latitude: Optional[float] = None
    longitude: Optional[float] = None
    altitude: Optional[float] = None
    placeName: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GeoLocation':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'GeoLocation':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class CameraInfo:
    """Generated class for CameraInfo."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "make": "make",
            "model": "model",
            "aperture": "aperture",
            "exposureTime": "exposureTime",
            "iso": "iso",
            "focalLength": "focalLength"
        }

    make: Optional[str] = None
    model: Optional[str] = None
    aperture: Optional[str] = None
    exposureTime: Optional[str] = None
    iso: Optional[int] = None
    focalLength: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CameraInfo':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'CameraInfo':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Transcript:
    """Generated class for Transcript."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "language": "language",
            "segments": "segments"
        }

    language: str
    segments: List["AnonymousObject"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Transcript':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Transcript':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class AccessControl:
    """Generated class for AccessControl."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "visibility": "visibility",
            "password": "password",
            "allowedUsers": "allowedUsers",
            "allowedGroups": "allowedGroups",
            "expiresAt": "expiresAt"
        }

    visibility: Optional["VisibilityEnum"] = None
    password: Optional[str] = None
    allowedUsers: Optional[List[str]] = field(default_factory=list)
    allowedGroups: Optional[List[str]] = field(default_factory=list)
    expiresAt: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AccessControl':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'AccessControl':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class MediaAsset:
    """Digital media asset with metadata and variants"""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "type_": "type",
            "status": "status",
            "mimeType": "mimeType",
            "variants": "variants",
            "originalFilename": "originalFilename",
            "fileSize": "fileSize",
            "checksum": "checksum",
            "metadata": "metadata",
            "transcripts": "transcripts",
            "tags": "tags",
            "collections": "collections",
            "accessControl": "accessControl",
            "analytics": "analytics",
            "ownerId": "ownerId",
            "createdAt": "createdAt",
            "updatedAt": "updatedAt"
        }

    id_: UUID
    type_: "TypeEnum"
    status: "StatusEnum"
    mimeType: str
    variants: List["AnonymousObject"]
    originalFilename: Optional[str] = None
    fileSize: Optional[int] = None
    checksum: Optional[str] = None
    metadata: Optional["Metadata"] = None
    transcripts: Optional[List["AnonymousObject"]] = field(default_factory=list)
    tags: Optional[List[str]] = field(default_factory=list)
    collections: Optional[List[str]] = field(default_factory=list)
    accessControl: Optional["Accesscontrol"] = None
    analytics: Optional["Analytics"] = None
    ownerId: Optional[str] = None
    createdAt: Optional[datetime] = None
    updatedAt: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MediaAsset':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'MediaAsset':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))
