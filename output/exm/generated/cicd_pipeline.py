from __future__ import annotations

"""
Auto-generated by JsonSchemaCodeGen v1.2.0
Generated: 2026-01-29T14:57:05.109632

Copyright (C) 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
# Generated from: 18_cicd_pipeline.json

"""
Auto-generated Python classes from JSON Schema.

Generated by JsonSchemaCodeGen on 2026-01-29 14:57:05

This module contains dataclasses generated from JSON Schema definitions.
Each class includes:
- Type hints for all properties
- Serialization methods (to_dict, to_json)
- Deserialization class methods (from_dict, from_json)
- Validation method to check required fields and enum values
"""


import json
from dataclasses import dataclass, field, asdict
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, date
from typing import Dict, Any
from typing import List


@dataclass
class ValidationResult:
    """Result of validation containing status and any errors."""
    is_valid: bool
    errors: List[str] = field(default_factory=list)
    
    def __str__(self) -> str:
        if self.is_valid:
            return "Valid"
        return f"Invalid: {'; '.join(self.errors)}"
    
    def __bool__(self) -> bool:
        return self.is_valid

@dataclass
class Stage:
    """Generated class for Stage."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "name": "name",
            "jobs": "jobs",
            "displayName": "displayName",
            "dependsOn": "dependsOn",
            "condition": "condition",
            "variables": "variables"
        }

    name: Optional[str] = None
    jobs: List["AnonymousObject"] = field(default_factory=list)
    displayName: Optional[str] = None
    dependsOn: List[str] = field(default_factory=list)
    condition: Optional[str] = None
    variables: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Stage':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Stage':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return ['name', 'jobs']

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class Job:
    """Generated class for Job."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "name": "name",
            "steps": "steps",
            "displayName": "displayName",
            "pool": "pool",
            "container": "container",
            "dependsOn": "dependsOn",
            "condition": "condition",
            "timeoutInMinutes": "timeoutInMinutes",
            "continueOnError": "continueOnError",
            "strategy": "strategy"
        }

    name: Optional[str] = None
    steps: List["AnonymousObject"] = field(default_factory=list)
    displayName: Optional[str] = None
    pool: Optional["Pool"] = None
    container: Optional["Container"] = None
    dependsOn: List[str] = field(default_factory=list)
    condition: Optional[str] = None
    timeoutInMinutes: Optional[int] = None
    continueOnError: Optional[bool] = None
    strategy: Optional["Strategy"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Job':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Job':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return ['name', 'steps']

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class Pool:
    """Generated class for Pool."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "name": "name",
            "vmImage": "vmImage",
            "demands": "demands"
        }

    name: Optional[str] = None
    vmImage: Optional[str] = None
    demands: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Pool':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Pool':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return []

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class Container:
    """Generated class for Container."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "image": "image",
            "options": "options",
            "env": "env",
            "volumes": "volumes"
        }

    image: Optional[str] = None
    options: Optional[str] = None
    env: Dict[str, Any] = field(default_factory=dict)
    volumes: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Container':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Container':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return ['image']

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class Step:
    """Generated class for Step."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "name": "name",
            "displayName": "displayName",
            "task": "task",
            "script": "script",
            "bash": "bash",
            "powershell": "powershell",
            "inputs": "inputs",
            "env": "env",
            "condition": "condition",
            "continueOnError": "continueOnError",
            "timeoutInMinutes": "timeoutInMinutes",
            "retryCountOnTaskFailure": "retryCountOnTaskFailure"
        }

    name: Optional[str] = None
    displayName: Optional[str] = None
    task: Optional[str] = None
    script: Optional[str] = None
    bash: Optional[str] = None
    powershell: Optional[str] = None
    inputs: Dict[str, Any] = field(default_factory=dict)
    env: Dict[str, Any] = field(default_factory=dict)
    condition: Optional[str] = None
    continueOnError: Optional[bool] = None
    timeoutInMinutes: Optional[int] = None
    retryCountOnTaskFailure: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Step':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Step':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return []

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class Strategy:
    """Generated class for Strategy."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "matrix": "matrix",
            "parallel": "parallel",
            "maxParallel": "maxParallel"
        }

    matrix: Dict[str, Any] = field(default_factory=dict)
    parallel: Optional[int] = None
    maxParallel: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Strategy':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Strategy':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return []

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class Trigger:
    """Generated class for Trigger."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "branches": "branches",
            "paths": "paths",
            "tags": "tags"
        }

    branches: Optional["Branches"] = None
    paths: Optional["Paths"] = None
    tags: Optional["Tags"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Trigger':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Trigger':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return []

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class Resource:
    """Generated class for Resource."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "repositories": "repositories",
            "containers": "containers"
        }

    repositories: List["AnonymousObject"] = field(default_factory=list)
    containers: List["AnonymousObject"] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Resource':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Resource':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return []

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)

@dataclass
class CICDPipeline:
    """CI/CD pipeline definition"""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "name": "name",
            "trigger": "trigger",
            "pr": "pr",
            "schedules": "schedules",
            "resources": "resources",
            "variables": "variables",
            "stages": "stages",
            "jobs": "jobs"
        }

    name: Optional[str] = None
    trigger: Optional["Trigger"] = None
    pr: Optional["Pr"] = None
    schedules: List["AnonymousObject"] = field(default_factory=list)
    resources: Optional["Resources"] = None
    variables: List["AnonymousObject"] = field(default_factory=list)
    stages: List["AnonymousObject"] = field(default_factory=list)
    jobs: List["AnonymousObject"] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CICDPipeline':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'CICDPipeline':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def _get_required_fields(cls) -> List[str]:
        """Get list of required field names."""
        return []

    @classmethod
    def _get_enum_constraints(cls) -> Dict[str, List[Any]]:
        """Get enum constraints for fields."""
        return {}

    def validate(self) -> 'ValidationResult':
        """
        Validate that all required fields are populated and enum values are valid.
        
        Returns:
            ValidationResult with is_valid flag and list of errors
        """
        errors = []
        
        # Check required fields
        for field_name in self._get_required_fields():
            value = getattr(self, field_name, None)
            if value is None:
                errors.append(f"Required field '{field_name}' is not set")
        
        # Check enum constraints
        for field_name, valid_values in self._get_enum_constraints().items():
            value = getattr(self, field_name, None)
            if value is not None and value not in valid_values:
                errors.append(f"Field '{field_name}' has invalid value '{value}'. Must be one of: {valid_values}")
        
        return ValidationResult(is_valid=len(errors) == 0, errors=errors)
