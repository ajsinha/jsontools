from __future__ import annotations

"""
Auto-generated by JsonSchemaCodeGen v1.1.0
Generated: 2026-01-29T13:36:20.801222

Copyright Â© 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
# Generated from: 08_event.json

"""
Auto-generated Python classes from JSON Schema.

Generated by JsonSchemaCodeGen on 2026-01-29 13:36:20

This module contains dataclasses generated from JSON Schema definitions.
Each class includes:
- Type hints for all properties
- Serialization methods (to_dict, to_json)
- Deserialization class methods (from_dict, from_json)
"""


import json
from dataclasses import dataclass, field, asdict
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, date
from typing import List
from uuid import UUID


@dataclass
class Attendee:
    """Generated class for Attendee."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "email": "email",
            "status": "status",
            "id_": "id",
            "name": "name",
            "role": "role",
            "responseTime": "responseTime"
        }

    email: str
    status: "StatusEnum"
    id_: Optional[UUID] = None
    name: Optional[str] = None
    role: Optional["RoleEnum"] = None
    responseTime: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Attendee':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Attendee':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Recurrence:
    """Generated class for Recurrence."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "frequency": "frequency",
            "interval": "interval",
            "daysOfWeek": "daysOfWeek",
            "dayOfMonth": "dayOfMonth",
            "monthOfYear": "monthOfYear",
            "count": "count",
            "until": "until",
            "exceptions": "exceptions"
        }

    frequency: "FrequencyEnum"
    interval: Optional[int] = 1
    daysOfWeek: Optional[List[str]] = field(default_factory=list)
    dayOfMonth: Optional[int] = None
    monthOfYear: Optional[int] = None
    count: Optional[int] = None
    until: Optional[date] = None
    exceptions: Optional[List[date]] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Recurrence':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Recurrence':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Reminder:
    """Generated class for Reminder."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "type_": "type",
            "minutesBefore": "minutesBefore"
        }

    type_: "TypeEnum"
    minutesBefore: int

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Reminder':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Reminder':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Location:
    """Generated class for Location."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "name": "name",
            "address": "address",
            "coordinates": "coordinates",
            "virtual": "virtual",
            "meetingUrl": "meetingUrl"
        }

    name: Optional[str] = None
    address: Optional[str] = None
    coordinates: Optional["Coordinates"] = None
    virtual: Optional[bool] = None
    meetingUrl: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Location':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Location':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Event:
    """Calendar event with recurrence and attendees"""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "title": "title",
            "start": "start",
            "end": "end",
            "description": "description",
            "allDay": "allDay",
            "timezone": "timezone",
            "location": "location",
            "organizer": "organizer",
            "attendees": "attendees",
            "recurrence": "recurrence",
            "reminders": "reminders",
            "status": "status",
            "visibility": "visibility",
            "color": "color",
            "createdAt": "createdAt",
            "updatedAt": "updatedAt"
        }

    id_: UUID
    title: str
    start: datetime
    end: datetime
    description: Optional[str] = None
    allDay: Optional[bool] = False
    timezone: Optional[str] = None
    location: Optional["Location"] = None
    organizer: Optional["Organizer"] = None
    attendees: Optional[List["AnonymousObject"]] = field(default_factory=list)
    recurrence: Optional["Recurrence"] = None
    reminders: Optional[List["AnonymousObject"]] = field(default_factory=list)
    status: Optional["StatusEnum"] = None
    visibility: Optional["VisibilityEnum"] = None
    color: Optional[str] = None
    createdAt: Optional[datetime] = None
    updatedAt: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Event':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Event':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))
