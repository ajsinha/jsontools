from __future__ import annotations

"""
Auto-generated by JsonSchemaCodeGen v1.1.0
Generated: 2026-01-29T13:36:20.799676

Copyright Â© 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
# Generated from: 06_config.json

"""
Auto-generated Python classes from JSON Schema.

Generated by JsonSchemaCodeGen on 2026-01-29 13:36:20

This module contains dataclasses generated from JSON Schema definitions.
Each class includes:
- Type hints for all properties
- Serialization methods (to_dict, to_json)
- Deserialization class methods (from_dict, from_json)
"""


import json
from dataclasses import dataclass, field, asdict
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, date
from typing import Dict, Any
from typing import List


@dataclass
class DatabaseConfig:
    """Generated class for DatabaseConfig."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "host": "host",
            "database": "database",
            "username": "username",
            "port": "port",
            "password": "password",
            "ssl": "ssl",
            "poolSize": "poolSize",
            "timeout": "timeout"
        }

    host: str
    database: str
    username: str
    port: Optional[int] = 5432
    password: Optional[str] = None
    ssl: Optional[bool] = False
    poolSize: Optional[int] = 10
    timeout: Optional[int] = 30000

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DatabaseConfig':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'DatabaseConfig':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class CacheConfig:
    """Generated class for CacheConfig."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "enabled": "enabled",
            "driver": "driver",
            "ttl": "ttl",
            "redis": "redis"
        }

    enabled: Optional[bool] = True
    driver: Optional["DriverEnum"] = None
    ttl: Optional[int] = 3600
    redis: Optional["Redis"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CacheConfig':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'CacheConfig':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class LoggingConfig:
    """Generated class for LoggingConfig."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "level": "level",
            "format": "format",
            "outputs": "outputs"
        }

    level: Optional["LevelEnum"] = None
    format: Optional["FormatEnum"] = None
    outputs: Optional[List["AnonymousObject"]] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LoggingConfig':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'LoggingConfig':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class SecurityConfig:
    """Generated class for SecurityConfig."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "jwtSecret": "jwtSecret",
            "jwtExpiry": "jwtExpiry",
            "bcryptRounds": "bcryptRounds",
            "cors": "cors",
            "rateLimit": "rateLimit"
        }

    jwtSecret: Optional[str] = None
    jwtExpiry: Optional[int] = 86400
    bcryptRounds: Optional[int] = 12
    cors: Optional["Cors"] = None
    rateLimit: Optional["Ratelimit"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SecurityConfig':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'SecurityConfig':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class ApplicationConfig:
    """Application configuration with nested settings"""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "app": "app",
            "database": "database",
            "server": "server",
            "cache": "cache",
            "logging": "logging",
            "security": "security",
            "features": "features"
        }

    app: "App"
    database: "Database"
    server: Optional["Server"] = None
    cache: Optional["Cache"] = None
    logging: Optional["Logging"] = None
    security: Optional["Security"] = None
    features: Optional[Dict[str, Any]] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ApplicationConfig':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'ApplicationConfig':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))
