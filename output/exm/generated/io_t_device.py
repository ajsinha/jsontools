from __future__ import annotations

"""
Auto-generated by JsonSchemaCodeGen v1.1.0
Generated: 2026-01-29T13:36:20.805407

Copyright Â© 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
# Generated from: 12_iot_device.json

"""
Auto-generated Python classes from JSON Schema.

Generated by JsonSchemaCodeGen on 2026-01-29 13:36:20

This module contains dataclasses generated from JSON Schema definitions.
Each class includes:
- Type hints for all properties
- Serialization methods (to_dict, to_json)
- Deserialization class methods (from_dict, from_json)
"""


import json
from dataclasses import dataclass, field, asdict
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, date
from typing import Dict, Any
from typing import List
from uuid import UUID


@dataclass
class Telemetry:
    """Generated class for Telemetry."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "timestamp": "timestamp",
            "temperature": "temperature",
            "humidity": "humidity",
            "pressure": "pressure",
            "battery": "battery",
            "signal": "signal",
            "custom": "custom"
        }

    timestamp: datetime
    temperature: Optional[float] = None
    humidity: Optional[float] = None
    pressure: Optional[float] = None
    battery: Optional[float] = None
    signal: Optional[int] = None
    custom: Optional[Dict[str, Any]] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Telemetry':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Telemetry':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Command:
    """Generated class for Command."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "name": "name",
            "parameters": "parameters",
            "timeout": "timeout",
            "qos": "qos"
        }

    id_: str
    name: str
    parameters: Optional[Dict[str, Any]] = field(default_factory=dict)
    timeout: Optional[int] = None
    qos: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Command':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Command':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Firmware:
    """Generated class for Firmware."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "version": "version",
            "buildDate": "buildDate",
            "checksum": "checksum",
            "updateAvailable": "updateAvailable",
            "lastUpdated": "lastUpdated"
        }

    version: str
    buildDate: Optional[date] = None
    checksum: Optional[str] = None
    updateAvailable: Optional[bool] = None
    lastUpdated: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Firmware':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Firmware':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class NetworkConfig:
    """Generated class for NetworkConfig."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "type_": "type",
            "ipAddress": "ipAddress",
            "macAddress": "macAddress",
            "ssid": "ssid",
            "rssi": "rssi"
        }

    type_: "TypeEnum"
    ipAddress: Optional[str] = None
    macAddress: Optional[str] = None
    ssid: Optional[str] = None
    rssi: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NetworkConfig':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'NetworkConfig':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Alert:
    """Generated class for Alert."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "type_": "type",
            "message": "message",
            "triggeredAt": "triggeredAt",
            "acknowledged": "acknowledged"
        }

    id_: str
    type_: "TypeEnum"
    message: str
    triggeredAt: datetime
    acknowledged: Optional[bool] = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Alert':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Alert':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class IoTDevice:
    """IoT device with telemetry and commands"""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "serialNumber": "serialNumber",
            "type_": "type",
            "status": "status",
            "name": "name",
            "model": "model",
            "manufacturer": "manufacturer",
            "firmware": "firmware",
            "network": "network",
            "location": "location",
            "telemetry": "telemetry",
            "commands": "commands",
            "alerts": "alerts",
            "tags": "tags",
            "metadata": "metadata",
            "lastSeen": "lastSeen",
            "registeredAt": "registeredAt"
        }

    id_: UUID
    serialNumber: str
    type_: "TypeEnum"
    status: "StatusEnum"
    name: Optional[str] = None
    model: Optional[str] = None
    manufacturer: Optional[str] = None
    firmware: Optional["Firmware"] = None
    network: Optional["Network"] = None
    location: Optional["Location"] = None
    telemetry: Optional["Telemetry"] = None
    commands: Optional[List["AnonymousObject"]] = field(default_factory=list)
    alerts: Optional[List["AnonymousObject"]] = field(default_factory=list)
    tags: Optional[List[str]] = field(default_factory=list)
    metadata: Optional[Dict[str, Any]] = field(default_factory=dict)
    lastSeen: Optional[datetime] = None
    registeredAt: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'IoTDevice':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'IoTDevice':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))
