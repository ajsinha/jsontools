from __future__ import annotations

"""
Auto-generated by JsonSchemaCodeGen v1.1.0
Generated: 2026-01-29T13:36:20.797481

Copyright Â© 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
# Generated from: 03_order.json

"""
Auto-generated Python classes from JSON Schema.

Generated by JsonSchemaCodeGen on 2026-01-29 13:36:20

This module contains dataclasses generated from JSON Schema definitions.
Each class includes:
- Type hints for all properties
- Serialization methods (to_dict, to_json)
- Deserialization class methods (from_dict, from_json)
"""


import json
from dataclasses import dataclass, field, asdict
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, date
from typing import List
from uuid import UUID


@dataclass
class Address:
    """Generated class for Address."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "firstName": "firstName",
            "lastName": "lastName",
            "street1": "street1",
            "city": "city",
            "postalCode": "postalCode",
            "country": "country",
            "company": "company",
            "street2": "street2",
            "state": "state",
            "phone": "phone"
        }

    firstName: str
    lastName: str
    street1: str
    city: str
    postalCode: str
    country: str
    company: Optional[str] = None
    street2: Optional[str] = None
    state: Optional[str] = None
    phone: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Address':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Address':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class LineItem:
    """Generated class for LineItem."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "productId": "productId",
            "name": "name",
            "quantity": "quantity",
            "unitPrice": "unitPrice",
            "variantId": "variantId",
            "sku": "sku",
            "totalPrice": "totalPrice",
            "discount": "discount"
        }

    id_: str
    productId: UUID
    name: str
    quantity: int
    unitPrice: int
    variantId: Optional[UUID] = None
    sku: Optional[str] = None
    totalPrice: Optional[int] = None
    discount: Optional["Discount"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LineItem':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'LineItem':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Discount:
    """Generated class for Discount."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "type_": "type",
            "value": "value",
            "code": "code",
            "amount": "amount"
        }

    type_: "TypeEnum"
    value: float
    code: Optional[str] = None
    amount: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Discount':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Discount':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Payment:
    """Generated class for Payment."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "method": "method",
            "status": "status",
            "amount": "amount",
            "currency": "currency",
            "transactionId": "transactionId",
            "paidAt": "paidAt"
        }

    id_: str
    method: "MethodEnum"
    status: "StatusEnum"
    amount: int
    currency: Optional[str] = None
    transactionId: Optional[str] = None
    paidAt: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Payment':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Payment':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Shipment:
    """Generated class for Shipment."""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "status": "status",
            "carrier": "carrier",
            "trackingNumber": "trackingNumber",
            "shippedAt": "shippedAt",
            "deliveredAt": "deliveredAt"
        }

    id_: str
    status: "StatusEnum"
    carrier: Optional[str] = None
    trackingNumber: Optional[str] = None
    shippedAt: Optional[datetime] = None
    deliveredAt: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Shipment':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Shipment':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))

@dataclass
class Order:
    """E-commerce order with line items and shipping"""

    # Property name mapping for JSON serialization
    @classmethod
    def _get_json_mapping(cls) -> Dict[str, str]:
        return {
            "id_": "id",
            "orderNumber": "orderNumber",
            "customerId": "customerId",
            "status": "status",
            "lineItems": "lineItems",
            "shippingAddress": "shippingAddress",
            "total": "total",
            "currency": "currency",
            "billingAddress": "billingAddress",
            "subtotal": "subtotal",
            "shippingCost": "shippingCost",
            "tax": "tax",
            "discounts": "discounts",
            "payments": "payments",
            "shipments": "shipments",
            "notes": "notes",
            "createdAt": "createdAt",
            "updatedAt": "updatedAt"
        }

    id_: UUID
    orderNumber: str
    customerId: UUID
    status: "StatusEnum"
    lineItems: List["AnonymousObject"]
    shippingAddress: "Shippingaddress"
    total: int
    currency: str
    billingAddress: Optional["Billingaddress"] = None
    subtotal: Optional[int] = None
    shippingCost: Optional[int] = None
    tax: Optional[int] = None
    discounts: Optional[List["AnonymousObject"]] = field(default_factory=list)
    payments: Optional[List["AnonymousObject"]] = field(default_factory=list)
    shipments: Optional[List["AnonymousObject"]] = field(default_factory=list)
    notes: Optional[str] = None
    createdAt: Optional[datetime] = None
    updatedAt: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with original JSON property names."""
        result = {}
        for py_name, json_name in self._get_json_mapping().items():
            value = getattr(self, py_name, None)
            if value is not None:
                if hasattr(value, 'to_dict'):
                    result[json_name] = value.to_dict()
                elif isinstance(value, list):
                    result[json_name] = [
                        item.to_dict() if hasattr(item, 'to_dict') else item
                        for item in value
                    ]
                elif isinstance(value, (datetime, date)):
                    result[json_name] = value.isoformat()
                else:
                    result[json_name] = value
        return result

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Order':
        """Create instance from dictionary."""
        reverse_mapping = {v: k for k, v in cls._get_json_mapping().items()}
        kwargs = {}
        for json_name, value in data.items():
            py_name = reverse_mapping.get(json_name, json_name)
            if py_name in cls.__annotations__:
                kwargs[py_name] = value
        return cls(**kwargs)

    @classmethod
    def from_json(cls, json_str: str) -> 'Order':
        """Create instance from JSON string."""
        return cls.from_dict(json.loads(json_str))
