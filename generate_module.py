#!/usr/bin/env python3
"""
Schema to Module Generator - Generate Python modules from JSON Schema folders.

Copyright © 2025-2030, All Rights Reserved
Ashutosh Sinha
Email: ajsinha@gmail.com

LEGAL NOTICE:
This software is proprietary and confidential. Unauthorized copying,
distribution, modification, or use is strictly prohibited without
explicit written permission from the copyright holder.

Patent Pending: Certain implementations may be subject to patent applications.

This tool generates a complete Python module structure from a folder of JSON schemas:
- Generates Python dataclasses for each schema
- Creates a 'generated' submodule with all generated classes
- Creates driver code for JSON parsing and serialization
- Generates proper __init__.py files for the module hierarchy

Usage:
    python generate_module.py --schema-dir ./schemas --output-dir ./my_models
    
    # Or programmatically:
    from generate_module import generate_module
    generate_module("./schemas", "./my_models", module_name="my_models")
"""

import argparse
import json
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent))

from jsonschemacodegen import SchemaProcessor, __version__
from jsonschemacodegen.utils import load_schema
from jsonschemacodegen.utils.naming import to_pascal_case, to_snake_case


# Copyright header for generated files
COPYRIGHT_HEADER = '''"""
{description}

Auto-generated by JsonSchemaCodeGen v{version}
Generated at: {timestamp}

Copyright © 2025-2030, All Rights Reserved
Ashutosh Sinha
Email: ajsinha@gmail.com

LEGAL NOTICE:
This software is proprietary and confidential. Unauthorized copying,
distribution, modification, or use is strictly prohibited without
explicit written permission from the copyright holder.

DO NOT EDIT THIS FILE MANUALLY - Changes will be overwritten.
"""
'''


def fix_future_imports(code: str, header: str) -> str:
    """
    Ensure __future__ imports come before the copyright header.
    """
    future_import = "from __future__ import annotations"
    
    if future_import in code:
        code = code.replace(future_import + "\n", "")
        code = code.replace(future_import, "")
        return future_import + "\n\n" + header + "\n" + code.lstrip()
    else:
        return header + "\n" + code


def get_class_name_from_schema(schema: Dict[str, Any], filename: str) -> str:
    """Extract or generate class name from schema."""
    if "title" in schema:
        # Convert title to PascalCase class name
        title = schema["title"]
        return to_pascal_case(title.replace(" ", "_").replace("-", "_"))
    
    # Use filename as fallback
    name = Path(filename).stem
    # Remove leading numbers and underscores (e.g., "01_user" -> "User")
    name = name.lstrip("0123456789_")
    return to_pascal_case(name)


def get_module_name_from_filename(filename: str) -> str:
    """Convert filename to valid Python module name."""
    name = Path(filename).stem.lower()
    # Remove leading numbers but keep underscores
    name = name.lstrip("0123456789")
    name = name.lstrip("_")
    # Ensure valid identifier
    if not name:
        name = "schema"
    return to_snake_case(name)


def discover_schemas(schema_dir: Path) -> List[Tuple[Path, Dict[str, Any]]]:
    """
    Discover all JSON schema files in a directory.
    
    Returns:
        List of (file_path, schema_dict) tuples
    """
    schemas = []
    
    for json_file in sorted(schema_dir.glob("*.json")):
        try:
            schema = load_schema(json_file)
            # Skip definition-only files (no type at root level)
            if "type" in schema or "properties" in schema or "allOf" in schema:
                schemas.append((json_file, schema))
        except Exception as e:
            print(f"Warning: Could not load {json_file}: {e}")
    
    return schemas


def generate_class_code(
    schema: Dict[str, Any],
    class_name: str,
    module_name: str,
) -> str:
    """Generate Python class code from schema."""
    processor = SchemaProcessor(schema, root_class_name=class_name)
    code = processor.generate_code(style="dataclass")
    return code


def generate_pydantic_code(
    schema: Dict[str, Any],
    class_name: str,
) -> str:
    """Generate Pydantic model code from schema."""
    processor = SchemaProcessor(schema, root_class_name=class_name)
    code = processor.generate_pydantic_models()
    return code


def generate_generated_init(
    class_info: List[Dict[str, str]],
    timestamp: str,
) -> str:
    """Generate __init__.py for the generated submodule."""
    
    imports = []
    all_classes = []
    
    for info in class_info:
        module = info["module_name"]
        class_name = info["class_name"]
        imports.append(f"from .{module} import {class_name}")
        all_classes.append(class_name)
    
    content = COPYRIGHT_HEADER.format(
        description="Generated Models - Auto-generated from JSON Schemas",
        version=__version__,
        timestamp=timestamp,
    )
    
    content += "# Import all generated classes\n"
    content += "\n".join(imports)
    content += "\n\n"
    
    content += "__all__ = [\n"
    for cls in all_classes:
        content += f'    "{cls}",\n'
    content += "]\n"
    
    # Add class registry
    content += """

# Class registry for dynamic instantiation
CLASS_REGISTRY = {
"""
    for info in class_info:
        content += f'    "{info["class_name"]}": {info["class_name"]},\n'
    content += """}


def get_class(name: str):
    \"\"\"Get a generated class by name.\"\"\"
    return CLASS_REGISTRY.get(name)


def list_classes() -> list:
    \"\"\"List all available generated classes.\"\"\"
    return list(CLASS_REGISTRY.keys())
"""
    
    return content


def generate_driver_code(
    class_info: List[Dict[str, str]],
    module_name: str,
    timestamp: str,
) -> str:
    """Generate driver code for JSON parsing and serialization."""
    
    content = COPYRIGHT_HEADER.format(
        description=f"{module_name} - Driver code for JSON parsing and serialization",
        version=__version__,
        timestamp=timestamp,
    )
    
    content += '''import json
from dataclasses import asdict, is_dataclass
from datetime import datetime, date
from pathlib import Path
from typing import Any, Dict, List, Optional, Type, TypeVar, Union
from uuid import UUID

from .generated import (
'''
    
    for info in class_info:
        content += f'    {info["class_name"]},\n'
    
    content += ''')
from .generated import CLASS_REGISTRY, get_class, list_classes


T = TypeVar("T")


class JSONEncoder(json.JSONEncoder):
    """Custom JSON encoder for dataclasses and special types."""
    
    def default(self, obj: Any) -> Any:
        if is_dataclass(obj) and not isinstance(obj, type):
            return asdict(obj)
        if isinstance(obj, datetime):
            return obj.isoformat()
        if isinstance(obj, date):
            return obj.isoformat()
        if isinstance(obj, UUID):
            return str(obj)
        if hasattr(obj, "to_dict"):
            return obj.to_dict()
        if hasattr(obj, "__dict__"):
            return obj.__dict__
        return super().default(obj)


def to_json(obj: Any, indent: int = 2, **kwargs) -> str:
    """
    Serialize an object to JSON string.
    
    Args:
        obj: Object to serialize (dataclass instance, dict, list, etc.)
        indent: JSON indentation level
        **kwargs: Additional arguments for json.dumps
        
    Returns:
        JSON string
        
    Example:
        user = User(id="123", name="John", email="john@example.com")
        json_str = to_json(user)
    """
    return json.dumps(obj, cls=JSONEncoder, indent=indent, **kwargs)


def to_dict(obj: Any) -> Dict[str, Any]:
    """
    Convert an object to dictionary.
    
    Args:
        obj: Object to convert
        
    Returns:
        Dictionary representation
    """
    if is_dataclass(obj) and not isinstance(obj, type):
        return asdict(obj)
    if hasattr(obj, "to_dict"):
        return obj.to_dict()
    if isinstance(obj, dict):
        return obj
    raise TypeError(f"Cannot convert {type(obj)} to dict")


def from_json(json_str: str, target_class: Type[T]) -> T:
    """
    Deserialize JSON string to a class instance.
    
    Args:
        json_str: JSON string to parse
        target_class: Target class to instantiate
        
    Returns:
        Instance of target_class
        
    Example:
        json_str = '{"id": "123", "name": "John", "email": "john@example.com"}'
        user = from_json(json_str, User)
    """
    data = json.loads(json_str)
    return from_dict(data, target_class)


def from_dict(data: Dict[str, Any], target_class: Type[T]) -> T:
    """
    Create a class instance from a dictionary.
    
    Args:
        data: Dictionary with field values
        target_class: Target class to instantiate
        
    Returns:
        Instance of target_class
        
    Example:
        data = {"id": "123", "name": "John", "email": "john@example.com"}
        user = from_dict(data, User)
    """
    if hasattr(target_class, "from_dict"):
        return target_class.from_dict(data)
    
    # Handle dataclass instantiation
    if is_dataclass(target_class):
        # Filter to only include fields that exist in the class
        import dataclasses
        field_names = {f.name for f in dataclasses.fields(target_class)}
        filtered_data = {k: v for k, v in data.items() if k in field_names}
        return target_class(**filtered_data)
    
    return target_class(**data)


def load_json_file(file_path: Union[str, Path], target_class: Type[T]) -> T:
    """
    Load a JSON file and parse into a class instance.
    
    Args:
        file_path: Path to JSON file
        target_class: Target class to instantiate
        
    Returns:
        Instance of target_class
        
    Example:
        user = load_json_file("user.json", User)
    """
    with open(file_path, "r", encoding="utf-8") as f:
        return from_json(f.read(), target_class)


def save_json_file(obj: Any, file_path: Union[str, Path], indent: int = 2) -> None:
    """
    Save an object to a JSON file.
    
    Args:
        obj: Object to serialize
        file_path: Path to save to
        indent: JSON indentation level
        
    Example:
        user = User(id="123", name="John", email="john@example.com")
        save_json_file(user, "user.json")
    """
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(to_json(obj, indent=indent))


def load_json_auto(json_str: str, class_hint: Optional[str] = None) -> Any:
    """
    Load JSON and automatically determine the appropriate class.
    
    Args:
        json_str: JSON string to parse
        class_hint: Optional hint for class name (uses $type field if not provided)
        
    Returns:
        Instance of the appropriate class, or dict if class cannot be determined
        
    Example:
        # With $type field in JSON
        json_str = '{"$type": "User", "id": "123", "name": "John"}'
        obj = load_json_auto(json_str)  # Returns User instance
        
        # With explicit hint
        obj = load_json_auto(json_str, class_hint="User")
    """
    data = json.loads(json_str)
    
    # Determine class name
    class_name = class_hint or data.pop("$type", None)
    
    if class_name:
        target_class = get_class(class_name)
        if target_class:
            return from_dict(data, target_class)
    
    return data


def create_instance(class_name: str, **kwargs) -> Any:
    """
    Create an instance of a generated class by name.
    
    Args:
        class_name: Name of the class to instantiate
        **kwargs: Field values
        
    Returns:
        Instance of the specified class
        
    Example:
        user = create_instance("User", id="123", name="John", email="john@example.com")
    """
    target_class = get_class(class_name)
    if target_class is None:
        raise ValueError(f"Unknown class: {class_name}. Available: {list_classes()}")
    return target_class(**kwargs)


# Re-export convenience items
__all__ = [
    # Classes
'''
    
    for info in class_info:
        content += f'    "{info["class_name"]}",\n'
    
    content += '''    
    # Functions
    "to_json",
    "to_dict",
    "from_json",
    "from_dict",
    "load_json_file",
    "save_json_file",
    "load_json_auto",
    "create_instance",
    "get_class",
    "list_classes",
    
    # Encoder
    "JSONEncoder",
]
'''
    
    return content


def generate_base_init(
    class_info: List[Dict[str, str]],
    module_name: str,
    timestamp: str,
) -> str:
    """Generate __init__.py for the base module."""
    
    content = COPYRIGHT_HEADER.format(
        description=f"{module_name} - Generated Python models from JSON Schema",
        version=__version__,
        timestamp=timestamp,
    )
    
    content += f'''"""
{module_name}
{"=" * len(module_name)}

Auto-generated Python models from JSON Schema definitions.

Quick Start:
    from {module_name} import User, to_json, from_json
    
    # Create an instance
    user = User(id="123", name="John", email="john@example.com")
    
    # Serialize to JSON
    json_str = to_json(user)
    
    # Parse from JSON
    user = from_json(json_str, User)
    
    # Load from file
    user = load_json_file("user.json", User)
    
    # Save to file
    save_json_file(user, "user.json")

Available Classes:
'''
    
    for info in class_info:
        content += f'    - {info["class_name"]}\n'
    
    content += f'''
Generated by JsonSchemaCodeGen v{__version__}
"""

__version__ = "1.0.0"

# Import all from driver module
from .driver import (
'''
    
    for info in class_info:
        content += f'    {info["class_name"]},\n'
    
    content += '''    to_json,
    to_dict,
    from_json,
    from_dict,
    load_json_file,
    save_json_file,
    load_json_auto,
    create_instance,
    get_class,
    list_classes,
    JSONEncoder,
)

# Also expose from generated submodule
from . import generated

__all__ = [
    "__version__",
    "generated",
'''
    
    for info in class_info:
        content += f'    "{info["class_name"]}",\n'
    
    content += '''    "to_json",
    "to_dict",
    "from_json",
    "from_dict",
    "load_json_file",
    "save_json_file",
    "load_json_auto",
    "create_instance",
    "get_class",
    "list_classes",
    "JSONEncoder",
]
'''
    
    return content


def generate_module(
    schema_dir: Union[str, Path],
    output_dir: Union[str, Path],
    module_name: Optional[str] = None,
    style: str = "dataclass",
    verbose: bool = True,
) -> Dict[str, Any]:
    """
    Generate a complete Python module from a folder of JSON schemas.
    
    Args:
        schema_dir: Directory containing JSON schema files
        output_dir: Directory to create the module in
        module_name: Name for the generated module (defaults to output dir name)
        style: Code style ("dataclass" or "pydantic")
        verbose: Print progress information
        
    Returns:
        Dictionary with generation results
        
    Example:
        result = generate_module(
            schema_dir="./schemas",
            output_dir="./my_models",
            module_name="my_models"
        )
        print(f"Generated {result['class_count']} classes")
    """
    schema_dir = Path(schema_dir)
    output_dir = Path(output_dir)
    
    if not schema_dir.exists():
        raise FileNotFoundError(f"Schema directory not found: {schema_dir}")
    
    # Determine module name
    if module_name is None:
        module_name = output_dir.name
    
    # Ensure valid Python identifier
    module_name = to_snake_case(module_name.replace("-", "_"))
    
    timestamp = datetime.now().isoformat()
    
    if verbose:
        print(f"JsonSchemaCodeGen Module Generator v{__version__}")
        print(f"=" * 50)
        print(f"Schema directory: {schema_dir}")
        print(f"Output directory: {output_dir}")
        print(f"Module name: {module_name}")
        print(f"Code style: {style}")
        print()
    
    # Discover schemas
    schemas = discover_schemas(schema_dir)
    
    if not schemas:
        raise ValueError(f"No valid JSON schemas found in {schema_dir}")
    
    if verbose:
        print(f"Found {len(schemas)} schemas to process")
    
    # Create directory structure
    output_dir.mkdir(parents=True, exist_ok=True)
    generated_dir = output_dir / "generated"
    generated_dir.mkdir(exist_ok=True)
    
    # Track generated classes
    class_info = []
    
    # Generate code for each schema
    for schema_path, schema in schemas:
        class_name = get_class_name_from_schema(schema, schema_path.name)
        module_file_name = get_module_name_from_filename(schema_path.name)
        
        if verbose:
            print(f"  Processing: {schema_path.name} -> {class_name}")
        
        # Generate code
        try:
            if style == "pydantic":
                code = generate_pydantic_code(schema, class_name)
            else:
                code = generate_class_code(schema, class_name, module_file_name)
            
            # Add copyright header
            full_code = COPYRIGHT_HEADER.format(
                description=f"{class_name} - Generated from {schema_path.name}",
                version=__version__,
                timestamp=timestamp,
            )
            full_code += code
            
            # Write to file
            output_file = generated_dir / f"{module_file_name}.py"
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(full_code)
            
            class_info.append({
                "class_name": class_name,
                "module_name": module_file_name,
                "schema_file": schema_path.name,
                "output_file": str(output_file),
            })
            
        except Exception as e:
            print(f"  Warning: Failed to generate {class_name}: {e}")
    
    if not class_info:
        raise RuntimeError("No classes were generated successfully")
    
    # Generate __init__.py for generated submodule
    generated_init = generate_generated_init(class_info, timestamp)
    with open(generated_dir / "__init__.py", "w", encoding="utf-8") as f:
        f.write(generated_init)
    
    # Generate driver code
    driver_code = generate_driver_code(class_info, module_name, timestamp)
    with open(output_dir / "driver.py", "w", encoding="utf-8") as f:
        f.write(driver_code)
    
    # Generate base __init__.py
    base_init = generate_base_init(class_info, module_name, timestamp)
    with open(output_dir / "__init__.py", "w", encoding="utf-8") as f:
        f.write(base_init)
    
    if verbose:
        print()
        print(f"Generated {len(class_info)} classes successfully!")
        print(f"Output directory: {output_dir}")
        print()
        print("Generated structure:")
        print(f"  {output_dir}/")
        print(f"  ├── __init__.py")
        print(f"  ├── driver.py")
        print(f"  └── generated/")
        print(f"      ├── __init__.py")
        for info in class_info:
            print(f"      └── {info['module_name']}.py  ({info['class_name']})")
        print()
        print("Usage example:")
        print(f"  from {module_name} import {class_info[0]['class_name']}, to_json, from_json")
        print()
    
    return {
        "module_name": module_name,
        "output_dir": str(output_dir),
        "class_count": len(class_info),
        "classes": class_info,
        "timestamp": timestamp,
    }


def main():
    """Command-line entry point."""
    parser = argparse.ArgumentParser(
        prog="generate_module",
        description="Generate Python modules from JSON Schema folders",
        epilog="Copyright © 2025-2030 Ashutosh Sinha. All Rights Reserved.",
    )
    
    parser.add_argument(
        "--schema-dir", "-s",
        required=True,
        help="Directory containing JSON schema files",
    )
    
    parser.add_argument(
        "--output-dir", "-o",
        required=True,
        help="Output directory for the generated module",
    )
    
    parser.add_argument(
        "--module-name", "-n",
        help="Name for the generated module (defaults to output directory name)",
    )
    
    parser.add_argument(
        "--style",
        choices=["dataclass", "pydantic"],
        default="dataclass",
        help="Code generation style (default: dataclass)",
    )
    
    parser.add_argument(
        "--quiet", "-q",
        action="store_true",
        help="Suppress progress output",
    )
    
    parser.add_argument(
        "--version", "-V",
        action="version",
        version=f"%(prog)s {__version__}",
    )
    
    args = parser.parse_args()
    
    try:
        result = generate_module(
            schema_dir=args.schema_dir,
            output_dir=args.output_dir,
            module_name=args.module_name,
            style=args.style,
            verbose=not args.quiet,
        )
        
        return 0
        
    except Exception as e:
        print(f"Error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
