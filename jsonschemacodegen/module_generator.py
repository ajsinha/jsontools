"""
Module Generator - Generate Python modules from JSON Schema folders.

Copyright © 2025-2030, All Rights Reserved
Ashutosh Sinha (ajsinha@gmail.com)

LEGAL NOTICE:
This software is proprietary and confidential. Unauthorized copying,
distribution, modification, or use is strictly prohibited without
explicit written permission from the copyright holder.

This module provides functionality to:
- Process entire folders of JSON Schema files
- Generate consistent Python dataclass models for all schemas
- Create a properly structured Python module with __init__.py files
- Generate driver code for JSON parsing and serialization
"""

import os
import sys
import json
import re
from pathlib import Path
from typing import Dict, List, Any, Optional, Union
from datetime import datetime

from .core.schema_processor import SchemaProcessor
from .utils.file_utils import load_schema
from .utils.naming import to_pascal_case, to_snake_case

__module_version__ = "1.0.0"

COPYRIGHT = '''"""
Auto-generated by JsonSchemaCodeGen v{version}
Generated: {timestamp}

Copyright © 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
'''


def _fix_future_imports(code: str, header: str) -> str:
    """Move __future__ imports to the beginning."""
    future = "from __future__ import annotations"
    if future in code:
        code = code.replace(future + "\n", "").replace(future, "")
        return future + "\n\n" + header + "\n" + code.lstrip()
    return header + "\n" + code


def _get_class_name(schema: Dict, filename: str) -> str:
    if "title" in schema:
        return to_pascal_case(schema["title"])
    name = re.sub(r'^\d+_', '', Path(filename).stem)
    return to_pascal_case(name) or "Schema"


def _get_module_name(schema: Dict, filename: str) -> str:
    if "title" in schema:
        return to_snake_case(schema["title"])
    name = re.sub(r'^\d+_', '', Path(filename).stem)
    return to_snake_case(name) or "schema"


class ModuleGenerator:
    """
    Generates a complete Python module from a folder of JSON Schema files.
    
    This class processes all JSON Schema files in a source directory and generates:
    - Python dataclass files in a 'generated' submodule
    - Driver code for JSON parsing and serialization
    - Proper __init__.py files for module structure
    - A registry of all generated classes
    
    Example:
        generator = ModuleGenerator(
            schema_dir="schemas/",
            output_dir="mymodule/"
        )
        result = generator.generate()
        
        # Now you can use:
        # from mymodule import load_json, to_json, User, Product
    """
    
    def __init__(
        self,
        schema_dir: str,
        output_dir: str,
        module_name: Optional[str] = None,
        overwrite: bool = True,
    ):
        """
        Initialize the module generator.
        
        Args:
            schema_dir: Path to directory containing JSON Schema files
            output_dir: Path where the Python module will be created
            module_name: Name for the module (defaults to output_dir basename)
            overwrite: Whether to overwrite existing files (default: True)
        """
        self.schema_dir = Path(schema_dir).resolve()
        self.output_dir = Path(output_dir).resolve()
        self.module_name = module_name or self.output_dir.name
        self.overwrite = overwrite
        
        self.generated_classes: Dict[str, str] = {}
        self.class_to_module: Dict[str, str] = {}
    
    def generate(self) -> Dict[str, Any]:
        """
        Generate the complete Python module.
        
        Returns:
            Dictionary with generation results
        """
        if not self.schema_dir.exists():
            raise FileNotFoundError(f"Schema directory not found: {self.schema_dir}")
        
        results = {
            "schemas_processed": 0,
            "classes_generated": [],
            "files_created": [],
            "errors": [],
        }
        
        # Create directory structure
        self.output_dir.mkdir(parents=True, exist_ok=True)
        generated_dir = self.output_dir / "generated"
        generated_dir.mkdir(exist_ok=True)
        
        # Process each schema file
        for schema_file in sorted(self.schema_dir.glob("*.json")):
            try:
                schema = load_schema(schema_file)
                class_name = _get_class_name(schema, schema_file.name)
                module_name = _get_module_name(schema, schema_file.name)
                
                # Handle duplicate class names
                if class_name in self.generated_classes:
                    base_name = class_name
                    counter = 2
                    while class_name in self.generated_classes:
                        class_name = f"{base_name}{counter}"
                        counter += 1
                
                processor = SchemaProcessor(schema, root_class_name=class_name)
                code = processor.generate_code(style="dataclass")
                
                timestamp = datetime.now().isoformat()
                header = COPYRIGHT.format(version=__module_version__, timestamp=timestamp)
                header += f'# Generated from: {schema_file.name}\n'
                full_code = _fix_future_imports(code, header)
                
                output_path = generated_dir / f"{module_name}.py"
                with open(output_path, 'w') as f:
                    f.write(full_code)
                
                self.generated_classes[class_name] = schema_file.name
                self.class_to_module[class_name] = module_name
                
                results["schemas_processed"] += 1
                results["files_created"].append(str(output_path))
                
            except Exception as e:
                results["errors"].append(f"{schema_file.name}: {str(e)}")
        
        # Generate __init__.py files
        self._generate_init_files(results)
        
        # Generate driver code
        self._generate_driver(results)
        
        results["classes_generated"] = list(self.generated_classes.keys())
        
        return results
    
    def _generate_init_files(self, results: Dict[str, Any]) -> None:
        """Generate __init__.py files."""
        timestamp = datetime.now().isoformat()
        
        # generated/__init__.py
        generated_init = self._create_generated_init(timestamp)
        init_path = self.output_dir / "generated" / "__init__.py"
        with open(init_path, 'w') as f:
            f.write(generated_init)
        results["files_created"].append(str(init_path))
        
        # main __init__.py
        main_init = self._create_main_init(timestamp)
        init_path = self.output_dir / "__init__.py"
        with open(init_path, 'w') as f:
            f.write(main_init)
        results["files_created"].append(str(init_path))
    
    def _create_generated_init(self, timestamp: str) -> str:
        """Create the generated/__init__.py content."""
        lines = [
            '"""',
            'Generated Models - Auto-generated by JsonSchemaCodeGen',
            '',
            'Copyright © 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)',
            f'Generated at: {timestamp}',
            '',
            'DO NOT EDIT - Changes will be overwritten.',
            '"""',
            '',
        ]
        
        # Imports
        for class_name, module_name in sorted(self.class_to_module.items()):
            lines.append(f"from .{module_name} import {class_name}")
        
        lines.append("")
        lines.append("__all__ = [")
        for class_name in sorted(self.generated_classes.keys()):
            lines.append(f'    "{class_name}",')
        lines.append("]")
        lines.append("")
        
        # Class registry
        lines.append("CLASS_REGISTRY = {")
        for class_name in sorted(self.generated_classes.keys()):
            lines.append(f'    "{class_name}": {class_name},')
        lines.append("}")
        lines.append("")
        lines.append("")
        lines.append("def get_class(name: str):")
        lines.append('    """Get a class by name from the registry."""')
        lines.append("    return CLASS_REGISTRY.get(name)")
        lines.append("")
        
        return "\n".join(lines)
    
    def _create_main_init(self, timestamp: str) -> str:
        """Create the main __init__.py content."""
        lines = [
            '"""',
            f'{self.module_name} - Generated Data Models',
            '',
            'Copyright © 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)',
            f'Generated at: {timestamp}',
            '',
            'Usage:',
            f'    from {self.module_name} import User, load_json, to_json',
            '"""',
            '',
            '# Import all generated classes',
            'from .generated import *',
            'from .generated import CLASS_REGISTRY, get_class',
            '',
            '# Import driver functions',
            'from .driver import (',
            '    load_json,',
            '    load_json_string,',
            '    load_dict,',
            '    to_json,',
            '    to_json_string,',
            '    to_dict,',
            '    list_classes,',
            ')',
            '',
            '__version__ = "1.0.0"',
            '',
        ]
        
        return "\n".join(lines)
    
    def _generate_driver(self, results: Dict[str, Any]) -> None:
        """Generate the driver.py file."""
        timestamp = datetime.now().isoformat()
        
        driver_code = f'''"""
Driver Code - JSON Loading and Serialization Utilities

Copyright © 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
Generated at: {timestamp}

This module provides utility functions for:
- Loading JSON files/strings into dataclass instances
- Serializing dataclass instances to JSON
"""

import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Type, TypeVar, Union
from dataclasses import is_dataclass, fields
from datetime import datetime, date

from .generated import CLASS_REGISTRY, get_class


T = TypeVar('T')


def load_json(file_path: Union[str, Path], target_class: Type[T]) -> T:
    """Load a JSON file into a dataclass instance."""
    file_path = Path(file_path)
    if not file_path.exists():
        raise FileNotFoundError(f"File not found: {{file_path}}")
    
    with open(file_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    return load_dict(data, target_class)


def load_json_string(json_str: str, target_class: Type[T]) -> T:
    """Load a JSON string into a dataclass instance."""
    data = json.loads(json_str)
    return load_dict(data, target_class)


def load_dict(data: Dict[str, Any], target_class: Type[T]) -> T:
    """Load a dictionary into a dataclass instance."""
    if not is_dataclass(target_class):
        raise TypeError(f"{{target_class}} is not a dataclass")
    
    field_types = {{f.name: f.type for f in fields(target_class)}}
    processed_data = {{}}
    
    for field_name, field_type in field_types.items():
        if field_name not in data:
            continue
        value = data[field_name]
        processed_data[field_name] = _convert_value(value, field_type)
    
    return target_class(**processed_data)


def _convert_value(value: Any, target_type: Any) -> Any:
    """Convert a value to the target type."""
    if value is None:
        return None
    
    origin = getattr(target_type, '__origin__', None)
    
    if origin is Union:
        args = target_type.__args__
        non_none = [t for t in args if t is not type(None)]
        if non_none:
            target_type = non_none[0]
            origin = getattr(target_type, '__origin__', None)
    
    if origin is list:
        item_type = target_type.__args__[0] if target_type.__args__ else Any
        return [_convert_value(item, item_type) for item in value]
    
    if origin is dict:
        return value
    
    if is_dataclass(target_type) and isinstance(value, dict):
        return load_dict(value, target_type)
    
    if target_type is datetime and isinstance(value, str):
        return datetime.fromisoformat(value.replace('Z', '+00:00'))
    
    if target_type is date and isinstance(value, str):
        return date.fromisoformat(value)
    
    return value


def to_json(obj: Any, file_path: Union[str, Path], indent: int = 2) -> None:
    """Serialize a dataclass instance to a JSON file."""
    file_path = Path(file_path)
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    json_str = to_json_string(obj, indent=indent)
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(json_str)


def to_json_string(obj: Any, indent: int = 2) -> str:
    """Serialize a dataclass instance to a JSON string."""
    data = to_dict(obj)
    return json.dumps(data, indent=indent, default=_json_serializer)


def to_dict(obj: Any) -> Dict[str, Any]:
    """Convert a dataclass instance to a dictionary."""
    if obj is None:
        return None
    
    if is_dataclass(obj) and not isinstance(obj, type):
        result = {{}}
        for field in fields(obj):
            value = getattr(obj, field.name)
            result[field.name] = to_dict(value)
        return result
    
    if isinstance(obj, list):
        return [to_dict(item) for item in obj]
    
    if isinstance(obj, dict):
        return {{k: to_dict(v) for k, v in obj.items()}}
    
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    
    return obj


def _json_serializer(obj: Any) -> Any:
    """Custom JSON serializer for special types."""
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    if hasattr(obj, '__dict__'):
        return obj.__dict__
    raise TypeError(f"Object of type {{type(obj)}} is not JSON serializable")


def list_classes() -> List[str]:
    """List all available generated classes."""
    return list(CLASS_REGISTRY.keys())
'''
        
        driver_path = self.output_dir / "driver.py"
        with open(driver_path, 'w') as f:
            f.write(driver_code)
        results["files_created"].append(str(driver_path))


def generate_module(
    schema_dir: str,
    output_dir: str,
    module_name: Optional[str] = None,
    overwrite: bool = True,
) -> Dict[str, Any]:
    """
    Convenience function to generate a Python module from JSON schemas.
    
    Args:
        schema_dir: Path to directory containing JSON Schema files
        output_dir: Path where the Python module will be created
        module_name: Name for the module (defaults to output_dir basename)
        overwrite: Whether to overwrite existing files (default: True)
        
    Returns:
        Dictionary with generation results
        
    Example:
        result = generate_module(
            schema_dir="schemas/",
            output_dir="myapp/models/",
            module_name="models"
        )
        print(f"Generated {len(result['classes_generated'])} classes")
    """
    generator = ModuleGenerator(
        schema_dir=schema_dir,
        output_dir=output_dir,
        module_name=module_name,
        overwrite=overwrite,
    )
    
    return generator.generate()
