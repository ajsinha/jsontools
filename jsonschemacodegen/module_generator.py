"""
Module Generator - Generate Python modules from JSON Schema folders.

Copyright (C) 2025-2030, All Rights Reserved
Ashutosh Sinha (ajsinha@gmail.com)

LEGAL NOTICE:
This software is proprietary and confidential. Unauthorized copying,
distribution, modification, or use is strictly prohibited without
explicit written permission from the copyright holder.

This module provides functionality to:
- Process entire folders of JSON Schema files
- Generate consistent Python dataclass models for all schemas
- Create a properly structured Python module with __init__.py files
- Generate driver code for JSON parsing and serialization
- Generate main.py with utility functions for JSON/class operations
"""

import os
import sys
import json
import re
from pathlib import Path
from typing import Dict, List, Any, Optional, Union
from datetime import datetime

from .core.schema_processor import SchemaProcessor
from .utils.file_utils import load_schema
from .utils.naming import to_pascal_case, to_snake_case

__module_version__ = "1.2.0"

COPYRIGHT = '''"""
Auto-generated by JsonSchemaCodeGen v{version}
Generated: {timestamp}

Copyright (C) 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
DO NOT EDIT - Changes will be overwritten.
"""
'''


def _fix_future_imports(code: str, header: str) -> str:
    """Move __future__ imports to the beginning."""
    future = "from __future__ import annotations"
    if future in code:
        code = code.replace(future + "\n", "").replace(future, "")
        return future + "\n\n" + header + "\n" + code.lstrip()
    return header + "\n" + code


def _get_class_name(schema: Dict, filename: str) -> str:
    if "title" in schema:
        return to_pascal_case(schema["title"])
    name = re.sub(r'^\d+_', '', Path(filename).stem)
    return to_pascal_case(name) or "Schema"


def _get_module_name(schema: Dict, filename: str) -> str:
    if "title" in schema:
        return to_snake_case(schema["title"])
    name = re.sub(r'^\d+_', '', Path(filename).stem)
    return to_snake_case(name) or "schema"


class ModuleGenerator:
    """
    Generates a complete Python module from a folder of JSON Schema files.
    
    This class processes all JSON Schema files in a source directory and generates:
    - A named module folder (default: mymodule) inside the output directory
    - Python dataclass files in a 'generated' submodule
    - Driver code for JSON parsing and serialization
    - Main.py with utility functions for loading/saving JSON
    - Proper __init__.py files for module structure
    - A registry of all generated classes
    
    Example:
        generator = ModuleGenerator(
            schema_dir="schemas/",
            output_dir="output/",
            module_name="mymodels"
        )
        result = generator.generate()
        
        # Creates:
        # output/
        # `-- mymodels/
        #     |-- __init__.py
        #     |-- driver.py
        #     |-- main.py
        #     `-- generated/
        #         |-- __init__.py
        #         `-- *.py
        
        # Now you can use:
        # from mymodels import load_json, to_json, User, Product
        # or run: python -m mymodels --help
    """
    
    DEFAULT_MODULE_NAME = "mymodule"
    
    def __init__(
        self,
        schema_dir: str,
        output_dir: str,
        module_name: Optional[str] = None,
        overwrite: bool = True,
        all_fields_optional: bool = True,
    ):
        """
        Initialize the module generator.
        
        Args:
            schema_dir: Path to directory containing JSON Schema files
            output_dir: Path where the module folder will be created
            module_name: Name for the module (default: "mymodule")
            overwrite: Whether to overwrite existing files (default: True)
            all_fields_optional: If True, all fields get defaults allowing empty constructor (default: True)
        """
        self.schema_dir = Path(schema_dir).resolve()
        self.output_dir = Path(output_dir).resolve()
        self.module_name = module_name or self.DEFAULT_MODULE_NAME
        self.overwrite = overwrite
        self.all_fields_optional = all_fields_optional
        
        # Module directory is inside output_dir
        self.module_dir = self.output_dir / self.module_name
        
        self.generated_classes: Dict[str, str] = {}
        self.class_to_module: Dict[str, str] = {}
    
    def generate(self) -> Dict[str, Any]:
        """
        Generate the complete Python module.
        
        Returns:
            Dictionary with generation results:
            - schemas_processed: Number of schemas processed
            - classes_generated: List of class names
            - files_created: List of file paths
            - errors: List of error messages
            - module_path: Path to generated module
        """
        if not self.schema_dir.exists():
            raise FileNotFoundError(f"Schema directory not found: {self.schema_dir}")
        
        results = {
            "schemas_processed": 0,
            "classes_generated": [],
            "files_created": [],
            "errors": [],
            "module_path": str(self.module_dir),
            "module_name": self.module_name,
        }
        
        # Create directory structure
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.module_dir.mkdir(exist_ok=True)
        generated_dir = self.module_dir / "generated"
        generated_dir.mkdir(exist_ok=True)
        
        # Process each schema file
        for schema_file in sorted(self.schema_dir.glob("*.json")):
            try:
                schema = load_schema(schema_file)
                class_name = _get_class_name(schema, schema_file.name)
                module_name = _get_module_name(schema, schema_file.name)
                
                # Handle duplicate class names
                if class_name in self.generated_classes:
                    base_name = class_name
                    counter = 2
                    while class_name in self.generated_classes:
                        class_name = f"{base_name}{counter}"
                        counter += 1
                
                # Pass base_uri for resolving relative $ref like "Bond.json"
                processor = SchemaProcessor(
                    schema, 
                    root_class_name=class_name,
                    base_uri=str(schema_file.resolve())
                )
                code = processor.generate_code(
                    style="dataclass",
                    all_fields_optional=self.all_fields_optional
                )
                
                timestamp = datetime.now().isoformat()
                header = COPYRIGHT.format(version=__module_version__, timestamp=timestamp)
                header += f'# Generated from: {schema_file.name}\n'
                full_code = _fix_future_imports(code, header)
                
                output_path = generated_dir / f"{module_name}.py"
                with open(output_path, 'w') as f:
                    f.write(full_code)
                
                self.generated_classes[class_name] = schema_file.name
                self.class_to_module[class_name] = module_name
                
                results["schemas_processed"] += 1
                results["files_created"].append(str(output_path))
                
            except Exception as e:
                results["errors"].append(f"{schema_file.name}: {str(e)}")
        
        # Generate __init__.py files
        self._generate_init_files(results)
        
        # Generate driver code
        self._generate_driver(results)
        
        # Generate main.py
        self._generate_main(results)
        
        # Generate __main__.py for python -m support
        self._generate_main_entry(results)
        
        results["classes_generated"] = list(self.generated_classes.keys())
        
        return results
    
    def _generate_init_files(self, results: Dict[str, Any]) -> None:
        """Generate __init__.py files."""
        timestamp = datetime.now().isoformat()
        
        # generated/__init__.py
        generated_init = self._create_generated_init(timestamp)
        init_path = self.module_dir / "generated" / "__init__.py"
        with open(init_path, 'w') as f:
            f.write(generated_init)
        results["files_created"].append(str(init_path))
        
        # main __init__.py
        main_init = self._create_main_init(timestamp)
        init_path = self.module_dir / "__init__.py"
        with open(init_path, 'w') as f:
            f.write(main_init)
        results["files_created"].append(str(init_path))
    
    def _create_generated_init(self, timestamp: str) -> str:
        """Create the generated/__init__.py content."""
        lines = [
            '"""',
            'Generated Models - Auto-generated by JsonSchemaCodeGen',
            '',
            'Copyright (C) 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)',
            f'Generated at: {timestamp}',
            '',
            'DO NOT EDIT - Changes will be overwritten.',
            '"""',
            '',
        ]
        
        # Imports
        for class_name, module_name in sorted(self.class_to_module.items()):
            lines.append(f"from .{module_name} import {class_name}")
        
        lines.append("")
        lines.append("__all__ = [")
        for class_name in sorted(self.generated_classes.keys()):
            lines.append(f'    "{class_name}",')
        lines.append("]")
        lines.append("")
        
        # Class registry
        lines.append("# Class registry for dynamic lookup")
        lines.append("CLASS_REGISTRY = {")
        for class_name in sorted(self.generated_classes.keys()):
            lines.append(f'    "{class_name}": {class_name},')
        lines.append("}")
        lines.append("")
        lines.append("")
        lines.append("def get_class(name: str):")
        lines.append('    """Get a class by name from the registry."""')
        lines.append("    return CLASS_REGISTRY.get(name)")
        lines.append("")
        
        return "\n".join(lines)
    
    def _create_main_init(self, timestamp: str) -> str:
        """Create the main __init__.py content."""
        lines = [
            '"""',
            f'{self.module_name} - Generated Data Models',
            '',
            'Copyright (C) 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)',
            f'Generated at: {timestamp}',
            '',
            'This module provides:',
            '- Generated dataclass models from JSON Schema',
            '- Functions to load JSON into model instances',
            '- Functions to serialize models to JSON',
            '- Utility functions for working with models',
            '',
            'Usage:',
            f'    from {self.module_name} import User, load_json, to_json',
            '',
            '    # Load from JSON file',
            '    user = load_json("user.json", "User")',
            '',
            '    # Create and serialize',
            '    user = User(name="John", email="john@example.com")',
            '    json_str = to_json_string(user)',
            '',
            'Command-line usage:',
            f'    python -m {self.module_name} --help',
            f'    python -m {self.module_name} list',
            f'    python -m {self.module_name} load user.json User',
            f'    python -m {self.module_name} sample User',
            '"""',
            '',
            '# Import all generated classes',
            'from .generated import *',
            'from .generated import CLASS_REGISTRY, get_class',
            '',
            '# Import driver functions',
            'from .driver import (',
            '    load_json,',
            '    load_json_file,',
            '    load_json_string,',
            '    load_dict,',
            '    to_json,',
            '    to_json_file,',
            '    to_json_string,',
            '    to_dict,',
            '    list_classes,',
            '    get_class_info,',
            '    create_instance,',
            '    validate_data,',
            ')',
            '',
            '# Import main functions',
            'from .main import (',
            '    load_and_parse,',
            '    create_and_save,',
            '    generate_sample,',
            '    convert_json,',
            '    run_cli,',
            ')',
            '',
            '__version__ = "1.2.0"',
            '',
        ]
        
        return "\n".join(lines)
    
    def _generate_driver(self, results: Dict[str, Any]) -> None:
        """Generate the driver.py file."""
        timestamp = datetime.now().isoformat()
        
        driver_code = f'''"""
Driver Code - JSON Loading and Serialization Utilities

Copyright (C) 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
Generated at: {timestamp}

This module provides utility functions for:
- Loading JSON files/strings into dataclass instances
- Serializing dataclass instances to JSON
- Class introspection and validation
"""

import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Type, TypeVar, Union
from dataclasses import is_dataclass, fields
from datetime import datetime, date

from .generated import CLASS_REGISTRY, get_class


T = TypeVar('T')


# ============================================================================
# JSON LOADING FUNCTIONS
# ============================================================================

def load_json(file_path: Union[str, Path], class_name: str) -> Any:
    """
    Load a JSON file into a dataclass instance.
    
    Args:
        file_path: Path to the JSON file
        class_name: Name of the target class
        
    Returns:
        Instance of the specified class
        
    Example:
        user = load_json("user.json", "User")
    """
    target_class = get_class(class_name)
    if target_class is None:
        raise ValueError(f"Unknown class: {{class_name}}. Available: {{list_classes()}}")
    return load_json_file(file_path, target_class)


def load_json_file(file_path: Union[str, Path], target_class: Type[T]) -> T:
    """
    Load a JSON file into a dataclass instance.
    
    Args:
        file_path: Path to the JSON file
        target_class: The dataclass type to instantiate
        
    Returns:
        Instance of target_class populated with JSON data
    """
    file_path = Path(file_path)
    if not file_path.exists():
        raise FileNotFoundError(f"File not found: {{file_path}}")
    
    with open(file_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    return load_dict(data, target_class)


def load_json_string(json_str: str, target_class: Type[T]) -> T:
    """
    Load a JSON string into a dataclass instance.
    
    Args:
        json_str: JSON string
        target_class: The dataclass type to instantiate
        
    Returns:
        Instance of target_class populated with JSON data
    """
    data = json.loads(json_str)
    return load_dict(data, target_class)


def load_dict(data: Dict[str, Any], target_class: Type[T]) -> T:
    """
    Load a dictionary into a dataclass instance.
    
    Args:
        data: Dictionary with data
        target_class: The dataclass type to instantiate
        
    Returns:
        Instance of target_class populated with data
    """
    if not is_dataclass(target_class):
        raise TypeError(f"{{target_class}} is not a dataclass")
    
    field_types = {{f.name: f.type for f in fields(target_class)}}
    processed_data = {{}}
    
    # Handle JSON property name mapping
    json_mapping = {{}}
    if hasattr(target_class, '_get_json_mapping'):
        mapping = target_class._get_json_mapping()
        json_mapping = {{v: k for k, v in mapping.items()}}  # Reverse: json_name -> py_name
    
    for json_name, value in data.items():
        # Convert JSON name to Python field name
        py_name = json_mapping.get(json_name, json_name)
        
        if py_name not in field_types:
            continue
            
        field_type = field_types[py_name]
        processed_data[py_name] = _convert_value(value, field_type)
    
    return target_class(**processed_data)


def _convert_value(value: Any, target_type: Any) -> Any:
    """Convert a value to the target type."""
    if value is None:
        return None
    
    origin = getattr(target_type, '__origin__', None)
    
    if origin is Union:
        args = target_type.__args__
        non_none = [t for t in args if t is not type(None)]
        if non_none:
            target_type = non_none[0]
            origin = getattr(target_type, '__origin__', None)
    
    if origin is list:
        item_type = target_type.__args__[0] if target_type.__args__ else Any
        return [_convert_value(item, item_type) for item in value]
    
    if origin is dict:
        return value
    
    if is_dataclass(target_type) and isinstance(value, dict):
        return load_dict(value, target_class=target_type)
    
    if target_type is datetime and isinstance(value, str):
        return datetime.fromisoformat(value.replace('Z', '+00:00'))
    
    if target_type is date and isinstance(value, str):
        return date.fromisoformat(value)
    
    return value


def create_instance(class_name: str, **kwargs) -> Any:
    """
    Create an instance of a class by name.
    
    Args:
        class_name: Name of the class
        **kwargs: Field values
        
    Returns:
        Instance of the class
        
    Example:
        user = create_instance("User", name="John", email="john@example.com")
    """
    target_class = get_class(class_name)
    if target_class is None:
        raise ValueError(f"Unknown class: {{class_name}}. Available: {{list_classes()}}")
    return target_class(**kwargs)


# ============================================================================
# JSON SERIALIZATION FUNCTIONS
# ============================================================================

def to_json(obj: Any, file_path: Union[str, Path], indent: int = 2) -> None:
    """
    Serialize a dataclass instance to a JSON file.
    
    Args:
        obj: The dataclass instance to serialize
        file_path: Output file path
        indent: JSON indentation
        
    Example:
        to_json(user, "user.json")
    """
    to_json_file(obj, file_path, indent)


def to_json_file(obj: Any, file_path: Union[str, Path], indent: int = 2) -> None:
    """
    Serialize a dataclass instance to a JSON file.
    
    Args:
        obj: The dataclass instance to serialize
        file_path: Output file path
        indent: JSON indentation
    """
    file_path = Path(file_path)
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    json_str = to_json_string(obj, indent=indent)
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(json_str)


def to_json_string(obj: Any, indent: int = 2) -> str:
    """
    Serialize a dataclass instance to a JSON string.
    
    Args:
        obj: The dataclass instance to serialize
        indent: JSON indentation
        
    Returns:
        JSON string
    """
    data = to_dict(obj)
    return json.dumps(data, indent=indent, default=_json_serializer)


def to_dict(obj: Any) -> Dict[str, Any]:
    """
    Convert a dataclass instance to a dictionary.
    
    Uses the JSON property name mapping if available.
    """
    if obj is None:
        return None
    
    if is_dataclass(obj) and not isinstance(obj, type):
        # Get JSON mapping if available
        json_mapping = {{}}
        if hasattr(obj, '_get_json_mapping'):
            json_mapping = obj._get_json_mapping()
        
        result = {{}}
        for field in fields(obj):
            value = getattr(obj, field.name)
            # Use JSON name if mapping exists
            json_name = json_mapping.get(field.name, field.name)
            result[json_name] = to_dict(value)
        return result
    
    if isinstance(obj, list):
        return [to_dict(item) for item in obj]
    
    if isinstance(obj, dict):
        return {{k: to_dict(v) for k, v in obj.items()}}
    
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    
    return obj


def _json_serializer(obj: Any) -> Any:
    """Custom JSON serializer for special types."""
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    if hasattr(obj, '__dict__'):
        return obj.__dict__
    raise TypeError(f"Object of type {{type(obj)}} is not JSON serializable")


# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def list_classes() -> List[str]:
    """
    List all available generated classes.
    
    Returns:
        List of class names
    """
    return list(CLASS_REGISTRY.keys())


def get_class_info(class_name: str) -> Optional[Dict[str, Any]]:
    """
    Get information about a generated class.
    
    Args:
        class_name: Name of the class
        
    Returns:
        Dictionary with class information
    """
    target_class = get_class(class_name)
    if target_class is None:
        return None
    
    if not is_dataclass(target_class):
        return None
    
    field_info = []
    for field in fields(target_class):
        has_default = field.default is not field.default_factory
        field_info.append({{
            "name": field.name,
            "type": str(field.type),
            "required": not has_default and field.default_factory is field.default_factory,
        }})
    
    return {{
        "name": class_name,
        "fields": field_info,
        "docstring": target_class.__doc__,
    }}


def validate_data(data: Dict[str, Any], class_name: str) -> Dict[str, Any]:
    """
    Validate data against a class structure.
    
    Args:
        data: Dictionary to validate
        class_name: Name of the target class
        
    Returns:
        Dictionary with validation results
    """
    target_class = get_class(class_name)
    if target_class is None:
        return {{"valid": False, "errors": [f"Unknown class: {{class_name}}"]}}
    
    errors = []
    warnings = []
    
    if not is_dataclass(target_class):
        return {{"valid": False, "errors": ["Not a dataclass"]}}
    
    # Check for required fields
    for field in fields(target_class):
        has_default = field.default is not field.default_factory
        if not has_default and field.default_factory is field.default_factory:
            # Required field
            json_name = field.name
            if hasattr(target_class, '_get_json_mapping'):
                mapping = target_class._get_json_mapping()
                json_name = mapping.get(field.name, field.name)
            
            if json_name not in data and field.name not in data:
                errors.append(f"Missing required field: {{json_name}}")
    
    # Try to instantiate
    try:
        load_dict(data, target_class)
    except Exception as e:
        errors.append(f"Instantiation error: {{e}}")
    
    return {{
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings,
    }}
'''
        
        driver_path = self.module_dir / "driver.py"
        with open(driver_path, 'w') as f:
            f.write(driver_code)
        results["files_created"].append(str(driver_path))
    
    def _generate_main(self, results: Dict[str, Any]) -> None:
        """Generate the main.py file with utility functions."""
        timestamp = datetime.now().isoformat()
        class_list = sorted(self.generated_classes.keys())
        
        main_code = f'''"""
Main Module - Utility Functions for JSON/Class Operations

Copyright (C) 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
Generated at: {timestamp}

This module provides high-level utility functions for:
- Loading JSON files and parsing into class instances
- Creating class instances and saving to JSON
- Generating sample data
- Converting between formats

Usage:
    from {self.module_name}.main import load_and_parse, create_and_save, generate_sample
    
    # Load JSON file into a class instance
    user = load_and_parse("user.json", "User")
    
    # Create instance and save to JSON
    create_and_save("User", "output.json", name="John", email="john@example.com")
    
    # Generate sample data
    sample = generate_sample("User")
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
from dataclasses import fields, is_dataclass
import random
import string
from datetime import datetime, date
from uuid import uuid4

from .driver import (
    load_json,
    load_json_file,
    load_dict,
    to_json,
    to_json_file,
    to_json_string,
    to_dict,
    list_classes,
    get_class_info,
    create_instance,
    validate_data,
)
from .generated import CLASS_REGISTRY, get_class


# ============================================================================
# HIGH-LEVEL UTILITY FUNCTIONS
# ============================================================================

def load_and_parse(
    file_path: Union[str, Path],
    class_name: str,
    verbose: bool = False,
) -> Any:
    """
    Load a JSON file and parse it into a class instance.
    
    Args:
        file_path: Path to the JSON file
        class_name: Name of the target class
        verbose: Print progress information
        
    Returns:
        Instance of the specified class
        
    Example:
        user = load_and_parse("data/user.json", "User")
        print(user.name)
    """
    if verbose:
        print(f"Loading {{file_path}} as {{class_name}}...")
    
    instance = load_json(file_path, class_name)
    
    if verbose:
        print(f"Successfully loaded {{class_name}} instance")
    
    return instance


def create_and_save(
    class_name: str,
    output_path: Union[str, Path],
    indent: int = 2,
    verbose: bool = False,
    **kwargs,
) -> Any:
    """
    Create a class instance and save it to a JSON file.
    
    Args:
        class_name: Name of the class to instantiate
        output_path: Path for the output JSON file
        indent: JSON indentation
        verbose: Print progress information
        **kwargs: Field values for the instance
        
    Returns:
        The created instance
        
    Example:
        user = create_and_save(
            "User",
            "output/user.json",
            name="John Doe",
            email="john@example.com"
        )
    """
    if verbose:
        print(f"Creating {{class_name}} instance...")
    
    instance = create_instance(class_name, **kwargs)
    
    if verbose:
        print(f"Saving to {{output_path}}...")
    
    to_json_file(instance, output_path, indent=indent)
    
    if verbose:
        print(f"Successfully saved {{class_name}} to {{output_path}}")
    
    return instance


def generate_sample(
    class_name: str,
    seed: Optional[int] = None,
) -> Any:
    """
    Generate a sample instance of a class with random data.
    
    Args:
        class_name: Name of the class
        seed: Random seed for reproducibility
        
    Returns:
        Instance with sample data
        
    Example:
        sample_user = generate_sample("User")
        print(sample_user.name)
    """
    if seed is not None:
        random.seed(seed)
    
    target_class = get_class(class_name)
    if target_class is None:
        raise ValueError(f"Unknown class: {{class_name}}. Available: {{list_classes()}}")
    
    if not is_dataclass(target_class):
        raise TypeError(f"{{class_name}} is not a dataclass")
    
    sample_data = {{}}
    for field in fields(target_class):
        sample_data[field.name] = _generate_sample_value(field.type, field.name)
    
    return target_class(**sample_data)


def _generate_sample_value(field_type: Any, field_name: str) -> Any:
    """Generate a sample value for a field."""
    origin = getattr(field_type, '__origin__', None)
    
    # Handle Optional
    if origin is Union:
        args = field_type.__args__
        non_none = [t for t in args if t is not type(None)]
        if non_none:
            field_type = non_none[0]
            origin = getattr(field_type, '__origin__', None)
        else:
            return None
    
    # Handle List
    if origin is list:
        item_type = field_type.__args__[0] if field_type.__args__ else str
        return [_generate_sample_value(item_type, field_name) for _ in range(random.randint(1, 3))]
    
    # Handle Dict
    if origin is dict:
        return {{"key": "value"}}
    
    # Handle basic types
    name_lower = field_name.lower()
    
    if field_type is str or field_type == 'str':
        if 'email' in name_lower:
            return f"user{{random.randint(1, 999)}}@example.com"
        elif 'name' in name_lower:
            return random.choice(["John", "Jane", "Bob", "Alice", "Charlie", "Diana"])
        elif 'id' in name_lower or 'uuid' in name_lower:
            return str(uuid4())
        elif 'url' in name_lower or 'uri' in name_lower:
            return "https://example.com/resource"
        elif 'phone' in name_lower:
            return f"+1-555-{{random.randint(100, 999)}}-{{random.randint(1000, 9999)}}"
        elif 'address' in name_lower:
            return f"{{random.randint(1, 999)}} Main Street"
        elif 'city' in name_lower:
            return random.choice(["New York", "Los Angeles", "Chicago", "Houston", "Phoenix"])
        elif 'country' in name_lower:
            return random.choice(["US", "UK", "CA", "AU", "DE", "FR"])
        elif 'title' in name_lower:
            return f"Sample Title {{random.randint(1, 100)}}"
        elif 'description' in name_lower:
            return "This is a sample description for testing purposes."
        else:
            return ''.join(random.choices(string.ascii_letters, k=10))
    
    if field_type is int or field_type == 'int':
        if 'age' in name_lower:
            return random.randint(18, 80)
        elif 'year' in name_lower:
            return random.randint(2020, 2025)
        elif 'count' in name_lower or 'quantity' in name_lower:
            return random.randint(1, 100)
        elif 'price' in name_lower or 'amount' in name_lower:
            return random.randint(1, 10000)
        else:
            return random.randint(1, 1000)
    
    if field_type is float or field_type == 'float':
        if 'price' in name_lower or 'amount' in name_lower:
            return round(random.uniform(1.0, 1000.0), 2)
        elif 'rate' in name_lower or 'percentage' in name_lower:
            return round(random.uniform(0.0, 100.0), 2)
        else:
            return round(random.uniform(0.0, 100.0), 2)
    
    if field_type is bool or field_type == 'bool':
        return random.choice([True, False])
    
    if field_type is datetime:
        return datetime.now()
    
    if field_type is date:
        return date.today()
    
    # Handle nested dataclass
    if is_dataclass(field_type):
        nested_data = {{}}
        for f in fields(field_type):
            nested_data[f.name] = _generate_sample_value(f.type, f.name)
        return field_type(**nested_data)
    
    # Default
    return None


def convert_json(
    input_path: Union[str, Path],
    output_path: Union[str, Path],
    class_name: str,
    indent: int = 2,
    verbose: bool = False,
) -> Any:
    """
    Load JSON, parse to class, and save back (useful for validation/normalization).
    
    Args:
        input_path: Input JSON file path
        output_path: Output JSON file path
        class_name: Name of the class
        indent: JSON indentation
        verbose: Print progress
        
    Returns:
        The parsed instance
        
    Example:
        # Validate and normalize JSON through the class
        user = convert_json("input.json", "output.json", "User")
    """
    if verbose:
        print(f"Loading {{input_path}}...")
    
    instance = load_json(input_path, class_name)
    
    if verbose:
        print(f"Saving to {{output_path}}...")
    
    to_json_file(instance, output_path, indent=indent)
    
    if verbose:
        print(f"Successfully converted {{class_name}}")
    
    return instance


# ============================================================================
# COMMAND-LINE INTERFACE
# ============================================================================

def run_cli(args: Optional[List[str]] = None) -> int:
    """
    Run the command-line interface.
    
    Args:
        args: Command-line arguments (defaults to sys.argv)
        
    Returns:
        Exit code (0 for success)
    """
    parser = argparse.ArgumentParser(
        prog="{self.module_name}",
        description="Generated Data Models - Load, create, and manipulate JSON data",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  List available classes:
    python -m {self.module_name} list
    
  Show class info:
    python -m {self.module_name} info User
    
  Load and display JSON:
    python -m {self.module_name} load user.json User
    
  Generate sample data:
    python -m {self.module_name} sample User
    python -m {self.module_name} sample User -o sample_user.json
    
  Validate JSON against class:
    python -m {self.module_name} validate user.json User

Copyright (C) 2025-2030, Ashutosh Sinha. All Rights Reserved.
""",
    )
    
    parser.add_argument("--version", action="version", version="1.0.0")
    
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # List command
    list_parser = subparsers.add_parser("list", help="List available classes")
    
    # Info command
    info_parser = subparsers.add_parser("info", help="Show class information")
    info_parser.add_argument("class_name", help="Name of the class")
    
    # Load command
    load_parser = subparsers.add_parser("load", help="Load and display JSON file")
    load_parser.add_argument("file", help="JSON file to load")
    load_parser.add_argument("class_name", help="Name of the class")
    load_parser.add_argument("-o", "--output", help="Output file (optional)")
    
    # Sample command
    sample_parser = subparsers.add_parser("sample", help="Generate sample data")
    sample_parser.add_argument("class_name", help="Name of the class")
    sample_parser.add_argument("-o", "--output", help="Output file (optional)")
    sample_parser.add_argument("-n", "--count", type=int, default=1, help="Number of samples")
    sample_parser.add_argument("--seed", type=int, help="Random seed")
    
    # Validate command
    validate_parser = subparsers.add_parser("validate", help="Validate JSON against class")
    validate_parser.add_argument("file", help="JSON file to validate")
    validate_parser.add_argument("class_name", help="Name of the class")
    
    parsed = parser.parse_args(args)
    
    if parsed.command is None:
        parser.print_help()
        return 0
    
    try:
        if parsed.command == "list":
            print("Available classes:")
            for name in sorted(list_classes()):
                print(f"  - {{name}}")
            return 0
        
        elif parsed.command == "info":
            info = get_class_info(parsed.class_name)
            if info is None:
                print(f"Unknown class: {{parsed.class_name}}")
                return 1
            print(f"Class: {{info['name']}}")
            print(f"Docstring: {{info['docstring'] or 'N/A'}}")
            print("Fields:")
            for f in info['fields']:
                req = " (required)" if f.get('required') else ""
                print(f"  - {{f['name']}}: {{f['type']}}{{req}}")
            return 0
        
        elif parsed.command == "load":
            instance = load_and_parse(parsed.file, parsed.class_name, verbose=True)
            json_str = to_json_string(instance)
            if parsed.output:
                with open(parsed.output, "w") as f:
                    f.write(json_str)
                print(f"Saved to {{parsed.output}}")
            else:
                print(json_str)
            return 0
        
        elif parsed.command == "sample":
            samples = []
            for i in range(parsed.count):
                seed = parsed.seed + i if parsed.seed else None
                samples.append(generate_sample(parsed.class_name, seed=seed))
            
            if parsed.count == 1:
                json_str = to_json_string(samples[0])
            else:
                json_str = json.dumps([to_dict(s) for s in samples], indent=2, default=str)
            
            if parsed.output:
                with open(parsed.output, "w") as f:
                    f.write(json_str)
                print(f"Generated {{parsed.count}} sample(s) to {{parsed.output}}")
            else:
                print(json_str)
            return 0
        
        elif parsed.command == "validate":
            with open(parsed.file, "r") as f:
                data = json.load(f)
            result = validate_data(data, parsed.class_name)
            if result["valid"]:
                print(f"[OK] {{parsed.file}} is valid for {{parsed.class_name}}")
            else:
                print(f"[ERROR] {{parsed.file}} has errors:")
                for err in result["errors"]:
                    print(f"  - {{err}}")
            return 0 if result["valid"] else 1
        
    except Exception as e:
        print(f"Error: {{e}}", file=sys.stderr)
        return 1
    
    return 0


if __name__ == "__main__":
    sys.exit(run_cli())
'''
        
        main_path = self.module_dir / "main.py"
        with open(main_path, 'w') as f:
            f.write(main_code)
        results["files_created"].append(str(main_path))
    
    def _generate_main_entry(self, results: Dict[str, Any]) -> None:
        """Generate __main__.py for python -m support."""
        timestamp = datetime.now().isoformat()
        
        main_entry_code = f'''"""
Module Entry Point - Enables python -m {self.module_name}

Copyright (C) 2025-2030, Ashutosh Sinha (ajsinha@gmail.com)
Generated at: {timestamp}
"""

import sys
from .main import run_cli

if __name__ == "__main__":
    sys.exit(run_cli())
'''
        
        main_entry_path = self.module_dir / "__main__.py"
        with open(main_entry_path, 'w') as f:
            f.write(main_entry_code)
        results["files_created"].append(str(main_entry_path))


def generate_module(
    schema_dir: str,
    output_dir: str,
    module_name: Optional[str] = None,
    overwrite: bool = True,
    all_fields_optional: bool = True,
) -> Dict[str, Any]:
    """
    Generate a Python module from a folder of JSON Schema files.
    
    Creates a complete, importable Python module with:
    - Generated dataclass models in a 'generated' submodule
    - Driver code for JSON loading/serialization
    - Main.py with utility functions
    - CLI support via python -m module_name
    
    Args:
        schema_dir: Path to directory containing JSON Schema files
        output_dir: Path where the module folder will be created
        module_name: Name for the module (default: "mymodule")
        overwrite: Whether to overwrite existing files (default: True)
        all_fields_optional: If True, all fields get defaults allowing empty constructor (default: True)
        
    Returns:
        Dictionary with generation results:
        - schemas_processed: Number of schemas processed
        - classes_generated: List of class names
        - files_created: List of file paths
        - errors: List of errors
        - module_path: Path to generated module
        - module_name: Name of the module
        
    Example:
        result = generate_module(
            schema_dir="schemas/",
            output_dir="output/",
            module_name="mymodels"
        )
        
        # Creates:
        # output/
        # `-- mymodels/
        #     |-- __init__.py
        #     |-- __main__.py
        #     |-- driver.py
        #     |-- main.py
        #     `-- generated/
        #         |-- __init__.py
        #         `-- *.py
        
        # Usage:
        # from mymodels import User, load_json, to_json
        # python -m mymodels list
    """
    generator = ModuleGenerator(
        schema_dir=schema_dir,
        output_dir=output_dir,
        module_name=module_name,
        overwrite=overwrite,
        all_fields_optional=all_fields_optional,
    )
    
    return generator.generate()
